"use strict";(self.webpackChunk_feasibleone_blong_docs=self.webpackChunk_feasibleone_blong_docs||[]).push([[3807],{8361:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});var i=o(9541),t=o(7743);const s={},c="Codec",r={id:"patterns/codec",title:"Codec",description:"Use the codecs to implement protocols on top of lower level ones.",source:"@site/docs/patterns/codec.md",sourceDirName:"patterns",slug:"/patterns/codec",permalink:"/blong-docs/docs/patterns/codec",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Adapter",permalink:"/blong-docs/docs/patterns/adapter"},next:{title:"Configuration",permalink:"/blong-docs/docs/patterns/configuration"}},d={},a=[{value:"Configuration",id:"configuration",level:2},{value:"HTTP codecs",id:"http-codecs",level:2},{value:"OpenAPI",id:"openapi",level:3},{value:"JSON-RPC",id:"json-rpc",level:3},{value:"Message Level Encryption",id:"message-level-encryption",level:3},{value:"TCP codecs",id:"tcp-codecs",level:2},{value:"Payshield",id:"payshield",level:2},{value:"SMPP",id:"smpp",level:2},{value:"APTRA/NDC",id:"aptrandc",level:2},{value:"ISO8583",id:"iso8583",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"codec",children:"Codec"}),"\n",(0,i.jsx)(n.p,{children:"Use the codecs to implement protocols on top of lower level ones."}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Codecs are configured by including their configuration in the\nadapter's configuration, while using their identifier (",(0,i.jsx)(n.code,{children:"codec.xxx"}),")\nas a key name. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export default realm(() => ({\n    dev: {\n        http: {\n            'codec.openapi': {\n                namespace: {}\n            }\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"http-codecs",children:"HTTP codecs"}),"\n",(0,i.jsxs)(n.p,{children:["The HTTP codecs can be imported in the HTTP adapter, to implement\nspecific functionality. They are implemented as a pair of ",(0,i.jsx)(n.code,{children:"send"})," and\n",(0,i.jsx)(n.code,{children:"receive"})," handlers."]}),"\n",(0,i.jsx)(n.p,{children:"The framework includes the following commonly used HTTP codecs:"}),"\n",(0,i.jsx)(n.h3,{id:"openapi",children:"OpenAPI"}),"\n",(0,i.jsxs)(n.p,{children:["Import ",(0,i.jsx)(n.code,{children:"codec.openapi"}),", to enable easy calling of external API, when it has\nOpenAPI or Swagger definition available. This usually happens at the server,\nwhen integrating with third party systems. The adapter can be called using an\n",(0,i.jsx)(n.code,{children:"operationId"})," from the API definition. Then this codec will determine the\nrequired HTTP method, path, headers and body for the request, based on the API\ndefinition. If operationId is not defined in the API, then it can be configured\nby merging and additional definition, that specifies operationId for each HTTP\nmethod and path."]}),"\n",(0,i.jsx)(n.p,{children:"This codec has the following configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"namespace:                           # API definitions per namespace\n  time:                              # Namespace for the definitions\n    - some/path/world-time.json      # OpenAPI/Swagger definition files\n    - some/path/world-time.operations.json\n  k8s:                               # Namespace for the definitions\n    - http://k8s.com/k8s-apps.json   # OpenAPI/Swagger definition URLs\n    - http://k8s.com/k8s-discovery.json\n    - http://k8s.com/k8s-version.json\n"})}),"\n",(0,i.jsx)(n.h3,{id:"json-rpc",children:"JSON-RPC"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"codec.jsonrpc"})," can be imported in the HTTP adapter, to enable easy calling\nof the framework's JSON-RPC based APIs. This is usually done in the front end,\nbut can be also used for other cases, like server to server calls.\nThis codec will automatically determine the path for the called method,\npass the parameters in the request body and process the response by returning\nthe result or the error of the call."]}),"\n",(0,i.jsx)(n.h3,{id:"message-level-encryption",children:"Message Level Encryption"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"codec.mle"})," can be imported in the HTTP adapter, to enable message level encryption\nwhen communicating with the framework's server. This codec must be put after ",(0,i.jsx)(n.code,{children:"codec.jsonrpc"}),"\nin the ",(0,i.jsx)(n.code,{children:"imports"})," array."]}),"\n",(0,i.jsx)(n.h2,{id:"tcp-codecs",children:"TCP codecs"}),"\n",(0,i.jsxs)(n.p,{children:["The TCP codecs can be imported in the TCP adapter, to implement\nspecific protocols. They are implemented as a pair of ",(0,i.jsx)(n.code,{children:"encode"})," and\n",(0,i.jsx)(n.code,{children:"decode"})," handlers."]}),"\n",(0,i.jsx)(n.p,{children:"The framework includes the following commonly used TCP codecs:"}),"\n",(0,i.jsx)(n.h2,{id:"payshield",children:"Payshield"}),"\n",(0,i.jsx)(n.h2,{id:"smpp",children:"SMPP"}),"\n",(0,i.jsx)(n.h2,{id:"aptrandc",children:"APTRA/NDC"}),"\n",(0,i.jsx)(n.h2,{id:"iso8583",children:"ISO8583"})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},7743:(e,n,o)=>{o.d(n,{Z:()=>r,a:()=>c});var i=o(3981);const t={},s=i.createContext(t);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);