"use strict";(self.webpackChunk_feasibleone_blong_docs=self.webpackChunk_feasibleone_blong_docs||[]).push([[1966],{6763:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=s(9541),n=s(8991);const o={},r="Adapter",i={id:"concepts/adapter",title:"Adapter",description:"Adapters are components within the framework, which take care of integration",source:"@site/docs/concepts/adapter.md",sourceDirName:"concepts",slug:"/concepts/adapter",permalink:"/blong-docs/docs/concepts/adapter",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/concepts/adapter.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concepts",permalink:"/blong-docs/docs/category/concepts"},next:{title:"Architecture",permalink:"/blong-docs/docs/concepts/architecture"}},d={},c=[{value:"Stream based",id:"stream-based",level:2},{value:"API based",id:"api-based",level:2},{value:"Adapter loop",id:"adapter-loop",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"adapter",children:"Adapter"}),"\n",(0,a.jsx)(t.p,{children:"Adapters are components within the framework, which take care of integration\nwith external systems. Their goal is to expose these systems as a high level\nAPI, which is compatible with the framework's naming conventions and also\nis independent of the API or protocol used by the external system."}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Adapter_pattern",children:"adapter design pattern"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"There are two types of adapters supported:"}),"\n",(0,a.jsx)(t.h2,{id:"stream-based",children:"Stream based"}),"\n",(0,a.jsx)(t.p,{children:"Stream based adapters usually communicate with the external system by implementing\na protocol, that operates directly on top TCP. They serialize and deserialize\nstream of bytes. This happens in two handlers:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"encode"}),": JavaScript objects passed to this handlers are converted to Buffer,\nwhich is then passed to the network."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"decode"}),": data frames coming from the network are passed to this handler and\nit converts them to JavaScript objects."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["This set of handlers is also known as ",(0,a.jsx)(t.code,{children:"codec"}),". Codecs usually also take care of\nmatching responses to their corresponding requests, as these protocols often allow\n",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multiplexing",children:"multiplexing"})]}),"\n",(0,a.jsx)(t.h2,{id:"api-based",children:"API based"}),"\n",(0,a.jsx)(t.p,{children:"API based adapters operate with higher level protocols like HTTP or even\nSDKs that are available for the external system. In this case the codec is not needed,\nas the API or SDK allows JavaScript objects to be used directly.\nHTTP is somewhere between the API based and stream based, as the transport\npart of the communication is solved by the protocol (i.e. request/response\nmatching and boundaries). There is still some need of serialization and deserialization\nof the request or response body,"}),"\n",(0,a.jsx)(t.h2,{id:"adapter-loop",children:"Adapter loop"}),"\n",(0,a.jsx)(t.p,{children:"The adapters perform a sequence of steps, where they call handlers with specific\nnames as per the following diagram:"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{alt:"adapter-loop",src:s(7019).Z+"#gh-dark-mode-only",width:"1026",height:"746"}),(0,a.jsx)(t.img,{alt:"adapter-loop",src:s(7082).Z+"#gh-light-mode-only",width:"1026",height:"746"})]}),"\n",(0,a.jsx)(t.p,{children:"When a handler with the corresponding name exists in the adapter, it can\ntransform the data being processed. Multiple handlers with the same name can be stacked\non top of each other, so that they address different aspects of the communication,\nfor example message level encryption and decryption can be implemented on top\nof the existing protocol."})]})}function p(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},7019:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/adapter-loop-dark-a63dc41f26842853fa4cfeb177cd697b.png"},7082:(e,t,s)=>{s.d(t,{Z:()=>a});const a=s.p+"assets/images/adapter-loop-light-271e48cadf3ebe4c51f8adc53fb7f7e4.png"},8991:(e,t,s)=>{s.d(t,{Z:()=>i,a:()=>r});var a=s(3981);const n={},o=a.createContext(n);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);